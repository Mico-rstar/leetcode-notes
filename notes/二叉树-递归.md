- [111. 二叉树的最小深度](#111-二叉树的最小深度)
  - [题解](#题解)
- [求根节点到叶节点数字之和](#求根节点到叶节点数字之和)
  - [题解](#题解-1)
- [好节点个数](#好节点个数)
  - [题解](#题解-2)
- [根叶路径上的不足节点](#根叶路径上的不足节点)
  - [分析](#分析)
  - [题解](#题解-3)
- [二叉搜索树范围和](#二叉搜索树范围和)
  - [思路](#思路)
  - [题解](#题解-4)
- [深化理解](#深化理解)
  - [基本代码模板](#基本代码模板)


### 111. 二叉树的最小深度
给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明：叶子节点是指没有子节点的节点。


[topic](https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/)

#### 题解
自底向上归
```cpp
int minDepth(TreeNode* root) {
    if (!root)
        return 0;

    if (!root->left) {
        return minDepth(root->right) + 1;
    } else if(!root->right)
    {
        return minDepth(root->left) + 1;
    } 
    else {
        return min(minDepth(root->left), minDepth(root->right)) + 1;
    }
}
```
自上向下递
```cpp

int minDepth(TreeNode* root) {
    int ans = INT_MAX;
    auto dfs = [&](this auto&& dfs, TreeNode* node, int cnt) -> void {
        if (node == nullptr) {
            return;
        }
        cnt++;
        if (node->left == nullptr && node->right == nullptr) { // node 是叶子
            ans = min(ans, cnt);
            return;
        }
        dfs(node->left, cnt);
        dfs(node->right, cnt);
    };
    dfs(root, 0);
    return root ? ans : 0;
}

// 作者：灵茶山艾府
// 链接：https://leetcode.cn/problems/minimum-depth-of-binary-tree/solutions/2730984/liang-chong-fang-fa-zi-ding-xiang-xia-zi-0sxz/
// 来源：力扣（LeetCode）
// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

如果发现cnt>=ans,由于继续递归不会减小cnt，因此可以直接返回，即最优性剪枝
```Cpp

int minDepth(TreeNode* root) {
    int ans = INT_MAX;
    auto dfs = [&](this auto&& dfs, TreeNode* node, int cnt) -> void {
        if (node == nullptr || ++cnt >= ans) { // 最优性剪枝
            return;
        }
        if (node->left == nullptr && node->right == nullptr) { // node 是叶子
            ans = cnt;
            return;
        }
        dfs(node->left, cnt);
        dfs(node->right, cnt);
    };
    dfs(root, 0);
    return root ? ans : 0;
}

// 作者：灵茶山艾府
// 链接：https://leetcode.cn/problems/minimum-depth-of-binary-tree/solutions/2730984/liang-chong-fang-fa-zi-ding-xiang-xia-zi-0sxz/
// 来源：力扣（LeetCode）
// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



---

### 求根节点到叶节点数字之和
给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：

- 例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
计算从根节点到叶节点生成的 所有数字之和 。

叶节点 是指没有子节点的节点。

[topic](https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/)

#### 题解
4 -> 9 -> 5
$$
x = 0 \\
x = 10 * x + 4 \\
x = 10 * x + 9 \\
x = 10 * x + 5 \\
x = 495
$$
```cpp
x = x * 10 + node->val;
```



```cpp
int sumNumbers(TreeNode* root) {
    int ans = 0;
    auto dfs = [&](this auto&& dfs, TreeNode *node, int x) -> void {
        if(!node) return;
        x = x * 10 + node->val;
        if(!node->left && !node->right)
        {
            ans += x;
            return;
        }
        dfs(node->left, x);
        dfs(node->right, x);
    };
    dfs(root, 0);
    return ans;
}
```

---

### 好节点个数
[topic](https://leetcode.cn/problems/count-good-nodes-in-binary-tree/description/)
#### 题解
```cpp
int goodNodes(TreeNode* root) {
    int cnt = 0;
    auto dfs = [&](this auto&& dfs, TreeNode *node, int max) -> void {
        if(!node) return;
        if(node->val >= max)
        {
            // 好节点
            max = node->val;
            cnt++;
        }
        dfs(node->left, max);
        dfs(node->right, max);
    };
    dfs(root, root->val);
    return cnt;
}
```
```cpp
int goodNodes(TreeNode* root, int mx = INT_MIN) {
    if(!root) return 0;
    int nmx = max(mx, root->val);
    int left = goodNodes(root->left, nmx);
    int right = goodNodes(root->right, nmx);
    return left + right + (root->val >= mx);
}
```



---

### 根叶路径上的不足节点
[topic](https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/description/)
- 根叶路径和：根到叶所有节点值的和
- 不足节点：经过该节点任何根叶路径和都小于limit

#### 分析
- 对于一个节点
  - 如果它是叶子节点，那么对比路径和与limit，若小于limit，应该删除
  - 如果它是非叶子节点，
    - 如果它的孩子都被删除，那么说明经过这个node的所有根叶路径和都小于limit，那么应该删除
    - 如果它还有孩子，那么至少还有一条路径是满足的，那么不用删除它

#### 题解
```cpp
TreeNode* sufficientSubset(TreeNode* root, int limit, int sumPath = 0) {
    sumPath += root->val;
    if (!root->left && !root->right)
        return (sumPath >= limit) ? root : nullptr;
    if (root->left)
        root->left =
            sufficientSubset(root->left, limit, sumPath);
    if (root->right)
        root->right =
            sufficientSubset(root->right, limit, sumPath);
    return root->left || root->right ? root : nullptr;
}
```
    

---

### 二叉搜索树范围和
[topic](https://leetcode.cn/problems/range-sum-of-bst/description/)
#### 思路
类比二分查找的做法，
$$
[low, high] = [low, +inf) - [high, +inf)
$$


#### 题解
```cpp
class Solution {
private:
    // 计算树中所有节点之和
    int sumTree(TreeNode *node) {
        int ans = 0;
        auto dfs = [&](this auto&& dfs, TreeNode *node) -> void {
            if(node == nullptr) return;
            ans += node->val;
            dfs(node->left);
            dfs(node->right);
        };
        dfs(node);
        return ans;
    }

    // 计算[bound, 无穷) 的值
    int lowerbound(TreeNode *node, int bound) {
        if(node == nullptr) return 0;
        if(bound > node->val){
            return lowerbound(node->right, bound);
         } else if(bound == node->val) {
            return node->val + sumTree(node->right);
         } else {
            return node->val + sumTree(node->right) + lowerbound(node->left, bound);
         }
    }
public:
    int rangeSumBST(TreeNode* root, int low, int high) {
        return lowerbound(root, low) - lowerbound(root, high + 1);
    }
};
```




---


### 深化理解
#### 基本代码模板
topic：求最大递归深度
```Cpp
// 自底向上归
int maxDepth(ListNode *root) {
    if(!root) return 0;
    lh = maxDepth(root->left);
    rh = maxDepth(root->right);

    return max(lh, rh) + 1;
}
```
```cpp
// 自顶向下递
int maxDepth(ListNode *root) {
    int ans = 0;
    auto dfs = [&](this auto&& dfs, TreeNode* root, int cnt) -> void
    {
        if(!root) return;
        ans = max(++cnt, ans);
        dfs(root->left, cnt);
        dfs(root->right, cnt);
    }; // 注意这里分号不可省
    dfs(root, 0);
    return ans;

}
```
