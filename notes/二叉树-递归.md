- [111. 二叉树的最小深度](#111-二叉树的最小深度)
  - [题解](#题解)
- [求根节点到叶节点数字之和](#求根节点到叶节点数字之和)
  - [题解](#题解-1)
- [好节点个数](#好节点个数)
  - [题解](#题解-2)
- [深化理解](#深化理解)
  - [基本代码模板](#基本代码模板)


### 111. 二叉树的最小深度
给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明：叶子节点是指没有子节点的节点。


[topic](https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/)

#### 题解
自底向上归
```cpp
int minDepth(TreeNode* root) {
    if (!root)
        return 0;

    if (!root->left) {
        return minDepth(root->right) + 1;
    } else if(!root->right)
    {
        return minDepth(root->left) + 1;
    } 
    else {
        return min(minDepth(root->left), minDepth(root->right)) + 1;
    }
}
```
自上向下递
```cpp

int minDepth(TreeNode* root) {
    int ans = INT_MAX;
    auto dfs = [&](this auto&& dfs, TreeNode* node, int cnt) -> void {
        if (node == nullptr) {
            return;
        }
        cnt++;
        if (node->left == nullptr && node->right == nullptr) { // node 是叶子
            ans = min(ans, cnt);
            return;
        }
        dfs(node->left, cnt);
        dfs(node->right, cnt);
    };
    dfs(root, 0);
    return root ? ans : 0;
}

// 作者：灵茶山艾府
// 链接：https://leetcode.cn/problems/minimum-depth-of-binary-tree/solutions/2730984/liang-chong-fang-fa-zi-ding-xiang-xia-zi-0sxz/
// 来源：力扣（LeetCode）
// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

如果发现cnt>=ans,由于继续递归不会减小cnt，因此可以直接返回，即最优性剪枝
```Cpp

int minDepth(TreeNode* root) {
    int ans = INT_MAX;
    auto dfs = [&](this auto&& dfs, TreeNode* node, int cnt) -> void {
        if (node == nullptr || ++cnt >= ans) { // 最优性剪枝
            return;
        }
        if (node->left == nullptr && node->right == nullptr) { // node 是叶子
            ans = cnt;
            return;
        }
        dfs(node->left, cnt);
        dfs(node->right, cnt);
    };
    dfs(root, 0);
    return root ? ans : 0;
}

// 作者：灵茶山艾府
// 链接：https://leetcode.cn/problems/minimum-depth-of-binary-tree/solutions/2730984/liang-chong-fang-fa-zi-ding-xiang-xia-zi-0sxz/
// 来源：力扣（LeetCode）
// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



---

### 求根节点到叶节点数字之和
给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：

- 例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
计算从根节点到叶节点生成的 所有数字之和 。

叶节点 是指没有子节点的节点。

[topic](https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/)

#### 题解
4 -> 9 -> 5
$$
x = 0 \\
x = 10 * x + 4 \\
x = 10 * x + 9 \\
x = 10 * x + 5 \\
x = 495
$$
```cpp
x = x * 10 + node->val;
```



```cpp
int sumNumbers(TreeNode* root) {
    int ans = 0;
    auto dfs = [&](this auto&& dfs, TreeNode *node, int x) -> void {
        if(!node) return;
        x = x * 10 + node->val;
        if(!node->left && !node->right)
        {
            ans += x;
            return;
        }
        dfs(node->left, x);
        dfs(node->right, x);
    };
    dfs(root, 0);
    return ans;
}
```

---

### 好节点个数
[topic](https://leetcode.cn/problems/count-good-nodes-in-binary-tree/description/)
#### 题解
```cpp
int goodNodes(TreeNode* root) {
    int cnt = 0;
    auto dfs = [&](this auto&& dfs, TreeNode *node, int max) -> void {
        if(!node) return;
        if(node->val >= max)
        {
            // 好节点
            max = node->val;
            cnt++;
        }
        dfs(node->left, max);
        dfs(node->right, max);
    };
    dfs(root, root->val);
    return cnt;
}
```
```cpp
int goodNodes(TreeNode* root, int mx = INT_MIN) {
    if(!root) return 0;
    int nmx = max(mx, root->val);
    int left = goodNodes(root->left, nmx);
    int right = goodNodes(root->right, nmx);
    return left + right + (root->val >= mx);
}
```


---


### 深化理解
#### 基本代码模板
topic：求最大递归深度
```Cpp
// 自底向上归
int maxDepth(ListNode *root) {
    if(!root) return 0;
    lh = maxDepth(root->left);
    rh = maxDepth(root->right);

    return max(lh, rh) + 1;
}
```
```cpp
// 自顶向下递
int maxDepth(ListNode *root) {
    int ans = 0;
    auto dfs = [&](this auto&& dfs, TreeNode* root, int cnt) -> void
    {
        if(!root) return;
        ans = max(++cnt, ans);
        dfs(root->left, cnt);
        dfs(root->right, cnt);
    }; // 注意这里分号不可省
    dfs(root, 0);
    return ans;

}
```
