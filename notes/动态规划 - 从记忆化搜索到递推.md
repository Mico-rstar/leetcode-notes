# 动态规划 - 从记忆化搜索到递推

## 深入理解例题
### 198. 打家劫舍
#### topic
[topic](https://leetcode.cn/problems/house-robber/description/)
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。


#### 题解
**1. 递归搜索**
```cpp
int rob(vector<int>& nums) {
    unordered_map<int, int> map;
    auto dfs = [&](this auto&& dfs, int i) -> int {
        if(i < 0) return 0;
        return max(dfs(i - 1), dfs(i - 2) + nums[i]);
    };
    return dfs(nums.size() - 1);
}
```


**2. 记忆化搜索**
```Cpp
int rob(vector<int>& nums) {
    unordered_map<int, int> map;
    auto dfs = [&](this auto&& dfs, int i) -> int {
        if(i < 0) return 0;
        int d1 = (map.contains(i - 1)) ? map[i - 1] : dfs(i - 1);
        map[i - 1] = d1;
        int d2 = (map.contains(i - 2)) ? map[i - 2] : dfs(i - 2);
        map[i - 2] = d2;
        return max(d1, d2 + nums[i]);
    };
    return dfs(nums.size() - 1);
}
```

**3. 递推**
```cpp
int rob(vector<int>& nums) {
    int ans = 0;
    int d1 = 0, d2 = 0;
    for(int i = 0; i < nums.size(); i++) {
        ans = max(d1, d2 + nums[i]);
        d2 = d1;
        d1 = ans;
    }
    return ans;
}
```

### 统计构造好字符串的方案数
#### topic
[topic](https://leetcode.cn/problems/count-ways-to-build-good-strings/description/)

#### 思路
状态转移方程
$$
dp[i] = dp[i-zero] + dp[i - one]
$$

#### 题解
```Cpp
int countGoodStrings(int low, int high, int zero, int one) {
    vector<unsigned> dp(high + 1, 0);
    const int MOD = 1e9 + 7;
    dp[0] = 1;
    for(int i = 1; i <= high; i++) {
        dp[i] = (((i - zero >= 0) ? dp[i - zero] : 0) + ((i - one >= 0) ? dp[i - one] : 0)) % MOD;
    }
    return std::accumulate(dp.begin() + low, dp.end(), 0, [](const unsigned& a, const unsigned &b){
        return (a + b) % MOD;
    });
}
```


